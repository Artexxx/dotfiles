# Руководство по fish для пользователей Bash

## Введение

Данное руководство поможет вам быстро ознакомиться с fish shell, если вы ранее пользовались Bash (или другими оболочками, такими как zsh или ksh) и хотите понять, чем fish отличается. Fish намеренно не совместим с POSIX, поэтому некоторые привычные команды и синтаксис работают иначе.

Несмотря на это, fish и Bash имеют много общего: выполнение командных строк, использование пайпов, перенаправлений, переменных, шаблонов и работы с выводом команд. Давайте подробно рассмотрим основные различия.


# Переменные

Fish устанавливает и удаляет переменные с помощью команды `set`, а не через конструкцию `VAR=VAL` и отдельные встроенные команды, такие как `declare`, `unset` и `export`. Команда `set` принимает параметры для определения области действия переменной и её свойства экспортируемости:

- Определение глобальной и экспортируемой переменной `$PAGER`:

  ```bash
  # Аналог команды `export PAGER=less`
  set -gx PAGER less
  ```

- Определение локальной переменной `$alocalvariable`:

  ```bash
  # Аналог `local alocalvariable=foo`
  set -l alocalvariable foo
  ```

Для удаления переменной используется:

```bash
set -e PAGER
```

Команды вида `VAR=VAL` используются как временные изменения переменных окружения:

```bash
PAGER=cat git log
```

Fish не выполняет разделение слов. Если переменной присвоено значение, оно остаётся неизменным при расширении, поэтому заключать переменные в двойные кавычки, как это необходимо в Bash, не требуется.

### Пример для Bash

```bash
foo="bar baz"
printf '"%s"\n' $foo
```

Результат:

```text
"bar"
"baz"
```

### Пример для Fish

```bash
set foo "bar baz"
printf '"%s"\n' $foo
```

Результат:

```text
"bar baz"
```

### Списки переменных

В Fish все переменные являются списками. Расширение переменной приводит к разбиению её значений на элементы, каждый из которых становится отдельным аргументом (аналог `${var[@]}` в Bash):

```bash
set var "foo bar" banana
printf %s\n $var
```

Результат:

```text
foo bar
banana
```

Можно выбирать конкретные элементы списка:

```bash
echo $list[5..7]
```

Аргументы команды `set` могут быть произвольными, что позволяет присваивать переменной результат выполнения команды:

```bash
# Присваиваем переменной lines все строки файла по одной строке на элемент
set lines (cat file)
```

Или можно смешивать литеральные значения и вывод команды:

```bash
set numbers 1 2 3 (seq 5 8) 9
printf '%s\n' $numbers
```

Результат:

```text
1
2
3
5
6
7
8
9
```

Использование `=` с `set` приводит к ошибкам:

```bash
# Присваивает переменной `foo` два значения: "=" и "bar"
set foo = bar

# Команда `set foo=bar` вызовет ошибку
set foo=bar
```

# Подстановки (шаблоны)

Fish поддерживает только шаблоны `*`, `**` и устаревший `?` для работы с подстановками файловых имен. Если шаблон не совпадает ни с одним файлом, команда завершится с ошибкой (аналогично опции `failglob` в Bash), за исключением случаев использования команд `for`, `set`, `count` или при использовании шаблона в переменной окружения (`VAR=* command`). В этих случаях шаблон разворачивается в пустую строку (аналог опции `nullglob` в Bash).

Подстановка не применяется к значениям переменных, например:

```bash
set foo "*"
echo $foo
```

Эта команда не отобразит список файлов.

### Особенности подстановок в Fish

- **Фиксированное поведение**: нельзя изменить настройки работы шаблонов — они всегда действуют по умолчанию.
- **Шаблон `**` для поиска в поддиректориях**: шаблон `**` ищет совпадения во вложенных директориях (в Bash для этого требуется включение опции `globstar`).
- **Следование по симлинкам**: в отличие от Bash, Fish переходит по символическим ссылкам.
- **Естественная сортировка**: результаты сортируются по "естественному" порядку, например, числа сортируются как числа (например, `1`, `2`, `10`, а не `1`, `10`, `2`).

Подробнее см. раздел [Wildcards](#).

---

# Кавычки

В Fish поддерживаются два типа кавычек: двойные `""` и одинарные `''`.

- **Двойные кавычки**: Внутри них происходит расширение переменных.
- **Одинарные кавычки**: Всё внутри них воспринимается как текст, без расширения переменных.

Отсутствует поддержка `$''` для преобразования последовательностей, но некавыченный текст преобразуется автоматически:

```bash
echo a\nb
```

Результат:

```text
a
b
```

---

# Манипуляции со строками

Fish не поддерживает такие конструкции, как `${foo%bar}`, `${foo#bar}` и `${foo/bar/baz}`. Вместо этого используется встроенная команда `string`.

### Замена подстрок

```bash
string replace bar baz "bar luhrmann"
```

Результат:

```text
baz luhrmann
```

### Разделение строк

```bash
string split "," "foo,bar"
```

Результат:

```text
foo
bar
```

### Регулярные выражения (аналог grep)

```bash
echo bababa | string match -r 'aba$'
```

Результат:

```text
aba
```

### Дополнение строки до заданной длины произвольными символами

```bash
string pad -c x -w 20 "foo"
```

Результат:

```text
xxxxxxxxxxxxxxxxxfoo
```

### Изменение регистра

- **Приведение к нижнему регистру**:

  ```bash
  string lower Foo
  ```

  Результат:

  ```text
  foo
  ```

- **Приведение к верхнему регистру**:

  ```bash
  string upper Foo
  ```

  Результат:

  ```text
  FOO
  ```

# Специальные переменные

Некоторые переменные Bash и их аналоги в Fish:

- `$*`, `$@`, `$1` и последующие: `$argv`
- `$?`: `$status`
- `$$`: `$fish_pid`
- `$#`: В Fish нет эквивалентной переменной, вместо этого используйте `count $argv`
- `$!`: `$last_pid`
- `$0`: `status filename`
- `$-`: Используйте `status is-interactive` и `status is-login`

---

# Подстановка процессов

Вместо конструкции `<(команда)` в Fish используется `(команда | psub)`. Эквивалента для `>(команда)` не существует.

Стоит отметить, что обе конструкции (`<()` и `>()`) относятся к специфике Bash, и большинство сценариев можно обойтись без них. Например:

```bash
# Bash
source <(command)
```

В Fish можно записать проще:

```bash
# Fish
command | source
```

Команда `source` в Fish поддерживает чтение из стандартного ввода.

---

# Here-документы

В Fish нет поддержки `<<EOF` (here-документов). Вместо этого используйте следующие варианты.

### Пример 1: Использование `printf`

```bash
printf %s\n "some string" "some more string"
```

### Пример 2: Использование `echo` с многострочным текстом

```bash
echo "some string
some more string"
```

### Пример 3: Разделение строк кавычками

```bash
echo "\
some string
some more string\
"
```

В Fish кавычки поддерживаются на нескольких строках.

### Что делает "here-документ"?

Here-документ выполняет следующие действия:

1. Читает/обрабатывает строки до терминатора (например, `EOF`) с особым набором правил.
2. Записывает обработанные строки во временный файл.
3. Передаёт этот файл как стандартный ввод (`stdin`) команде, с которой он используется.

По сути, это аналог команды с использованием пайпа:

```bash
echo "foo" | cat
```

Это почти то же самое, что:

```bash
cat <<EOF
foo
EOF
```

### Взаимодействие с `stdin`

Как и с here-документом, команда должна быть готова читать данные из стандартного ввода. Иногда для этого требуется явное указание специального аргумента `-`, который говорит программе, что данные поступают из `stdin`.

### Пример: использование `pacman`

```bash
echo "xterm
rxvt-unicode" | pacman --remove -
```

Аналогичный пример с here-документом в других shell:

```bash
pacman --remove - <<EOF
xterm
rxvt-unicode
EOF
```

Здесь `-` сообщает `pacman`, что аргументы нужно читать из `stdin`.

---

### Почему в Fish отсутствует поддержка here-документов?

Here-документы добавляют синтаксический сахар и множество правил обработки, которые усложняют понимание кода. В Fish всё строится вокруг пайпов (`|`), которые являются базовой концепцией и обеспечивают простоту и лучшую сочетаемость команд.

# Арифметические выражения

В Fish нет арифметического расширения вида `$((i+1))`. Для вычислений используется команда `math`:

```bash
math $i + 1
```

В отличие от Bash, `math` поддерживает вычисления с плавающей запятой:

```bash
math 5 / 2
```

Результат:

```text
2.5
```

### Поддержка функций

Fish поддерживает математические функции, такие как тригонометрические:

```bash
math cos 2 x pi
```

Результат:

```text
1
```

Аргументы могут передаваться по отдельности или в кавычках. Поскольку Fish использует скобки `()` для подстановок команд, выражения со скобками нужно оборачивать в кавычки:

```bash
math '(5 + 2) * 4'
```

Для умножения можно использовать как `*`, так и `x`, но `*` нужно экранировать или заключать в кавычки, чтобы избежать ошибки из-за его трактовки как шаблона подстановки.


# Промпты

Fish не использует переменные `$PS1`, `$PS2` и другие для настройки командной строки. Вместо этого используется вывод функции `fish_prompt`. Если включён режим `vi`, то также применяется функция `fish_mode_prompt`. Функция `fish_right_prompt` задаёт вывод для правого промпта.

### Пример

Простой промпт в Bash:

```bash
PS1='\h\[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\] '
```

Эквивалентный промпт в Fish:

```fish
function fish_prompt
    set -l prompt_symbol '$'
    fish_is_root_user; and set prompt_symbol '#'

    echo -s (prompt_hostname) \
    (set_color blue) (prompt_pwd) \
    (set_color yellow) $prompt_symbol (set_color normal)
end
```

### Основные отличия:

- Fish использует `set_color` для окрашивания текста. Поддерживаются 16 именованных цветов и RGB-записи (например, `set_color 5555FF`).
- Вместо специальных escape-последовательностей (например, `\h` для имени хоста) Fish использует функции. Для вывода имени хоста используется `prompt_hostname`.
- Fish поддерживает функции для добавления других элементов к промпту, например `fish_vcs_prompt` для отображения информации о системах контроля версий (Git, Mercurial, SVN) и `prompt_pwd` для вывода сокращённого пути (домашняя директория `~`, а компоненты пути сокращаются).

### Промпт для продолжения строк

Вместо использования `$PS2`, Fish оставляет последующие строки с отступом, чтобы показать, что команда ещё не завершена.

---

# Блоки и циклы

Конструкции блоков в Fish отличаются по синтаксису. Они начинаются с ключевого слова, заканчиваются `end` и не имеют парных закрывающих слов, как `do/done`.

### Примеры:

**Цикл for:**

```bash
# Bash
for i in 1 2 3; do
   echo $i
done

# Fish
for i in 1 2 3
   echo $i
end
```

**Цикл while:**

```bash
# Bash
while true; do
   echo Weeee
done

# Fish
while true
   echo Weeee
end
```

**Блоки команд:**

```bash
# Bash
{
   echo Hello
}

# Fish
begin
   echo Hello
end
```

**Условные конструкции if/else:**

```bash
# Bash
if true; then
   echo Yes I am true
else
   echo "How is true not true?"
fi

# Fish
if true
   echo Yes I am true
else
   echo "How is true not true?"
end
```

**Функции:**

```bash
# Bash
foo() {
   echo foo
}

# Fish
function foo
    echo foo
end
```

Bash позволяет использовать ключевое слово `function`, но это необязательно. В Fish же определение функций всегда начинается с `function` и заканчивается `end`.

---

### Особенности циклов

- В Fish отсутствует цикл `until`. Вместо него используйте `while not` или `while !`:

```bash
# Bash
until [condition]; do
    commands
done

# Fish
while not [condition]
    commands
end
```

# Подпроцессы (Subshells)

В Bash существует механизм "подпроцессов" (subshells), когда для выполнения определённых действий создаётся отдельный процесс оболочки. Этот процесс изолирован, и изменения переменных внутри него не влияют на основную оболочку.

### Примеры использования подпроцессов в Bash

1. Список команд в круглых скобках `()`:
   ```bash
   (foo; bar) | baz
   ```

2. Обе стороны пайпа:
   ```bash
   foo | while read -r bar; do
       # Изменения переменных видны только внутри цикла
       VAR=VAL
       # Фоновый процесс также не виден снаружи
       baz &
   done
   ```

### Подпроцессы в Fish

Fish **не поддерживает подпроцессы**. Это значит, что команда в Fish не будет автоматически запускаться в новом процессе оболочки. Для изоляции можно использовать локальные переменные:

```bash
set -l VAR VAL
```

Если необходимо выполнить код в новой среде оболочки, можно явно вызвать новый экземпляр Fish с помощью:

```bash
fish -c 'ваш код'
```

### Группировка команд

Часто подпроцессы в `()` путают с блоками команд `{}`, которые **не создают новый процесс**. В Fish для группировки используется `begin ... end`:

```bash
# Bash с подпроцессами
(foo; bar) | baz

# Bash с группировкой (без подпроцесса)
{ foo; bar; } | baz

# Эквивалент в Fish
begin
    foo
    bar
end | baz
```

Команды внутри `begin ... end` выполняются в **том же процессе**, что позволяет циклам `while read` изменять глобальные переменные и запускать фоновые процессы:

```fish
foo | while read bar
    # Устанавливаем глобальную переменную
    set -g VAR VAL
    # Запускаем команду в фоновом режиме
    baz &
end

# Переменная VAR доступна после цикла
echo $VAR  # выведет VAL

# Фоновая команда отображается в списке процессов
jobs  # покажет "baz"
```

---

### Подстановка команд

Подпроцессы также путают с подстановками команд. В Bash они записываются как `` `команда` `` или `$(команда)`, а в Fish только как `$(команда)`:

```bash
# Bash
echo $(date)

# Fish
echo (date)
```

Таким образом, в Fish использование подстановки команд или группировки с `begin ... end` покрывает большинство сценариев, где в Bash используются подпроцессы.
